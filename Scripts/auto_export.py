#!/usr/bin/env python3
"""
Automatic Agent Exporter

Automatically exports a trained RL agent to a standalone Python file
by extracting code from the source file using AST parsing.
This eliminates the need to manually edit agent_utils.py.
"""

import ast
import os
import sys
import argparse
import pickle
import inspect
from typing import Dict, Any, List, Set
import numpy as np


def extract_agent_code(agent_file_path: str) -> Dict[str, Any]:
    """
    Extract agent class definition from source file using AST parsing.
    
    Returns:
        Dictionary containing:
        - class_name: Name of the agent class
        - init_code: __init__ method source code
        - methods: Dictionary of method_name -> source_code
        - imports: Set of import statements needed
        - constants: Class-level constants
    """
    with open(agent_file_path, 'r') as f:
        source = f.read()
    
    tree = ast.parse(source)
    
    # Find the agent class (should inherit from BaseAgent)
    agent_class = None
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            # Check if it inherits from BaseAgent
            for base in node.bases:
                if isinstance(base, ast.Name) and base.id == 'BaseAgent':
                    agent_class = node
                    break
            if agent_class:
                break
    
    if not agent_class:
        raise ValueError(f"No class inheriting from BaseAgent found in {agent_file_path}")
    
    # Extract methods
    methods = {}
    init_code = None
    
    for item in agent_class.body:
        if isinstance(item, ast.FunctionDef):
            # Get the source code for this method
            method_source = ast.get_source_segment(source, item)
            if item.name == '__init__':
                init_code = method_source
            else:
                methods[item.name] = method_source
    
    # Extract imports (simplified - get common ones)
    imports = {
        'import numpy as np',
        'from agents.base_agent import BaseAgent'
    }
    
    return {
        'class_name': agent_class.name,
        'init_code': init_code,
        'methods': methods,
        'imports': imports
    }


def load_q_table(model_path: str) -> Dict[tuple, np.ndarray]:
    """Load Q-table from pickle file."""
    with open(model_path, 'rb') as f:
        data = pickle.load(f)
        if isinstance(data, dict) and 'q_table' in data:
            return data['q_table']
        else:
            # Old format - direct Q-table
            return data


def generate_standalone_agent(
    agent_code: Dict[str, Any],
    q_table: Dict[tuple, np.ndarray],
    output_path: str,
    exported_class_name: str = None
):
    """
    Generate a standalone Python file with the trained agent.
    
    Args:
        agent_code: Extracted agent code from extract_agent_code()
        q_table: Trained Q-table
        output_path: Where to save the standalone file
        exported_class_name: Optional name for exported class (default: original name + "Trained")
    """
    if exported_class_name is None:
        exported_class_name = f"{agent_code['class_name']}Trained"
    
    # Start building the file
    lines = [
        '"""',
        'Trained Agent for Sailing Challenge - Auto-generated',
        '',
        'This file was automatically generated by auto_export.py',
        'DO NOT EDIT MANUALLY - regenerate using the export script',
        '"""',
        '',
    ]
    
    # Add imports
    for imp in sorted(agent_code['imports']):
        lines.append(imp)
    lines.append('')
    lines.append('')
    
    # Start class definition
    lines.append(f'class {exported_class_name}(BaseAgent):')
    lines.append('    """')
    lines.append(f'    Trained {agent_code["class_name"]} with embedded Q-table.')
    lines.append('    """')
    lines.append('')
    
    # Add __init__ method with Q-table initialization
    if agent_code['init_code']:
        # Add the init code
        init_lines = agent_code['init_code'].split('\n')
        for line in init_lines:
            lines.append('    ' + line if line else '')
        
        lines.append('')
        lines.append('        # Load trained Q-table')
        lines.append('        self._init_q_table()')
        lines.append('')
    
    # Add Q-table initialization method
    lines.append('    def _init_q_table(self):')
    lines.append('        """Initialize Q-table with trained values."""')
    
    # Add Q-table entries
    for state, values in q_table.items():
        q_values_str = np.array2string(values, precision=4, separator=', ', max_line_width=120)
        lines.append(f'        self.q_table[{state}] = np.array({q_values_str})')
    
    lines.append('')
    
    # Add all other methods
    for method_name, method_code in sorted(agent_code['methods'].items()):
        # Skip methods that shouldn't be in exported version
        if method_name in ['learn', 'save', 'load']:
            continue
        
        method_lines = method_code.split('\n')
        for line in method_lines:
            lines.append('    ' + line if line else '')
        lines.append('')
    
    # Add required methods if missing
    if 'reset' not in agent_code['methods']:
        lines.append('    def reset(self):')
        lines.append('        """Reset agent state."""')
        lines.append('        pass')
        lines.append('')
    
    if 'seed' not in agent_code['methods']:
        lines.append('    def seed(self, seed=None):')
        lines.append('        """Set random seed."""')
        lines.append('        self.np_random = np.random.default_rng(seed)')
        lines.append('')
    
    # Write to file
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))
    
    return exported_class_name


def main():
    parser = argparse.ArgumentParser(
        description='Automatically export a trained agent to a standalone file'
    )
    parser.add_argument(
        '--agent-file',
        required=True,
        help='Path to the agent source file (e.g., src/agents/my_agent_physics.py)'
    )
    parser.add_argument(
        '--model-file',
        required=True,
        help='Path to the trained model pickle file (e.g., models/physics_agent.pkl)'
    )
    parser.add_argument(
        '--output',
        required=True,
        help='Output path for standalone agent file (e.g., Submission_agents/my_agent.py)'
    )
    parser.add_argument(
        '--class-name',
        help='Optional name for the exported class (default: OriginalNameTrained)'
    )
    
    args = parser.parse_args()
    
    try:
        print(f"üîç Extracting agent code from {args.agent_file}...")
        agent_code = extract_agent_code(args.agent_file)
        print(f"   Found class: {agent_code['class_name']}")
        print(f"   Methods: {', '.join(agent_code['methods'].keys())}")
        
        print(f"\nüì¶ Loading Q-table from {args.model_file}...")
        q_table = load_q_table(args.model_file)
        print(f"   Q-table size: {len(q_table)} states")
        
        print(f"\nüî® Generating standalone agent file...")
        class_name = generate_standalone_agent(
            agent_code,
            q_table,
            args.output,
            args.class_name
        )
        
        print(f"‚úÖ Success! Exported {class_name} to {args.output}")
        print(f"\nYou can now evaluate with:")
        print(f"  python src/evaluate_submission.py {args.output} --wind_scenario training_1 --num-seeds 100")
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        if '--verbose' in sys.argv:
            import traceback
            traceback.print_exc()
        return 1
    
    return 0


if __name__ == '__main__':
    sys.exit(main())
